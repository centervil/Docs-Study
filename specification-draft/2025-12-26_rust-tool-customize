# Rust製 Web漫画更新検知ツール 導入・カスタマイズ計画書

## 1. プロジェクト概要
Rustで記述された「Web漫画更新検知ツール」を、OCI（Oracle Cloud Infrastructure）上のLinuxサーバーで運用するための導入計画。
開発環境はDockerコンテナ内に構築し、**Tailscale VPN経由**でSSH接続を行う。
コーディングおよびビルドは、コンテナ内のTerminal操作とAIエージェント（gemini-cli）とのペアプログラミングのみで完結させる。

## 2. アーキテクチャ構成

*   **インフラ**: OCI Linux Instance (ARM64 / 4 vCPUs / 24GB RAM)
*   **ネットワーク**: Tailscale VPN（VPN内のプライベートネットワーク経由でアクセス）
*   **コンテナ構成**:
    1.  **Dev Container (開発用)**
        *   役割: Rust開発、ビルド、実行テスト、AIペアプログラミング
        *   環境: Rust公式イメージ + SSH Server + gemini-cli
        *   接続: VPN経由でSSH接続 (パスワード認証)
    2.  **Prod Container (本番用)**
        *   役割: 24時間稼働用
        *   環境: 軽量Linuxイメージ (Distroless または Debian-slim) + コンパイル済みバイナリ

## 3. フェーズ別タスク

### Phase 1: 開発用コンテナの構築
Tailscale VPN経由でSSH接続でき、AIエージェントが動作する開発環境を用意する。

1.  **作業ディレクトリの準備**:
    *   ホスト上にプロジェクト用のディレクトリを作成する。
2.  **開発用 Dockerfile の作成**:
    *   Rust公式イメージ（Debianベース）を使用する。
    *   必要なパッケージ（git, openssh-server, エディタ, python3/pip等）をインストールする記述を行う。
    *   **gemini-cli** をインストールする手順を追加する。
    *   **SSH設定**:
        *   公開鍵認証ではなく**パスワード認証**を利用するため、rootユーザーのパスワードを設定し、SSH設定ファイルでrootログインとパスワード認証を許可する。
3.  **docker-compose.yml の作成**:
    *   **ポート設定**: コンテナのSSHポート(22)をホスト側の任意のポート（例: 2222）にマッピングする。
        *   *注記*: Tailscale経由のため、OCIのファイアウォール（Security List）でこのポートをインターネットに公開する必要はない。
    *   **ボリューム**: ソースコードを永続化するため、ホストのディレクトリをマウントする。
    *   **環境変数**: Gemini APIキーなどをコンテナに渡す設定を行う。
4.  **起動と接続確認**:
    *   コンテナを起動し、PCからVPN経由でSSH接続してログインできるか確認する。
    *   コンテナ内で `gemini` コマンドが動作するか確認する。

### Phase 2: ソースコードの取得と構造理解 (DDD)
AIエージェントを活用し、ディレクトリ構造とコードの役割を把握する。

1.  **リポジトリの取得**:
    *   コンテナ内で対象のリポジトリをクローンする。
2.  **構造解析**:
    *   Geminiに対し、DDDの観点からディレクトリ構成（domain, infrastructure, usecase等）の解説を求める。
    *   特に「サイト追加時に修正すべきファイル」と「設定ファイルの読み込みロジック」を特定させる。

### Phase 3: 既存コードでの動作確認 (初回ビルド)
コードを修正せず、まずはオリジナルの状態でビルド・実行できるかを確認する。

1.  **依存関係の解決**:
    *   `cargo check` を実行し、必要なライブラリのダウンロードとコンパイルチェックを行う。
    *   OCI (ARM64) 特有のビルドエラーが出ないか確認する。
2.  **設定ファイルの準備**:
    *   リポジトリ内のサンプル設定ファイル（`.env.example` や `config.toml` など）をコピーし、動作に必要な最低限の設定を行う。
    *   *※この段階では通知先URL等はダミーでも良いが、サーバーが起動することを目指す。*
3.  **ビルドと実行**:
    *   `cargo run` を実行し、アプリケーションを立ち上げる。
    *   ログが出力され、プロセスが落ちずに待機状態（サーバーモード）になるかを確認する。
4.  **機能テスト**:
    *   別のターミナルから `curl` 等でローカルAPIを叩き、登録済みのデフォルトサイト（もしあれば）の更新チェックが走るか、あるいはエラーログが正しく出るかを確認する。

### Phase 4: カスタマイズ (サイト追加)
動作確認が取れた環境で、AIに実装を依頼して拡張を行う。

1.  **ターゲットサイトの分析**:
    *   対象となるWeb漫画サイトのHTML構造を調査し、タイトルや話数を取得するためのセレクタを特定する。
2.  **Parserの実装 (Infrastructure層)**:
    *   既存のParserコードをGeminiに読み込ませ、それをテンプレートとして新しいサイト用のParserコードを生成させる。
3.  **Domainへの登録**:
    *   作成したParserをアプリケーションが認識できるよう、FactoryやMain処理の該当箇所に登録コードを追加する。
4.  **再ビルド & テスト**:
    *   `cargo run` で再度実行し、新しく追加したサイトがクロールできるか確認する。

### Phase 5: 本番運用 (デプロイ)
完成したアプリケーションを軽量コンテナで常時稼働させる。

1.  **本番用 Dockerfile の作成**:
    *   マルチステージビルドを採用し、ビルドステージで `cargo build --release` を実行。
    *   実行ステージで、生成されたバイナリのみを軽量イメージにコピーする。
2.  **デプロイ**:
    *   本番用コンテナを起動し、Tailscaleネットワーク内または通知先（Discord等）への連携が正常に機能するか確認する。

## 4. 開発時のAIプロンプト戦略 (Rust x DDD)

*   **エラー解決**:
    *   「Rustのコンパイラエラーが出た。以下のエラーメッセージと該当コードから、修正方法をコードブロックで提示して。」
*   **DDDの適用**:
    *   「この処理はインフラ層（Webスクレイピング）に依存しているが、ドメイン層のインターフェースはどうなっている？どのファイルに実装すべきか教えて。」
*   **ビルドトラブル**:
    *   「ARM64環境でビルド中に `openssl` 関連のエラーが出た。Dockerfileに追加すべきパッケージは何？」
